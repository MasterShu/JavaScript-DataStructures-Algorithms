[sorting]
== 排序
排序是你必须了解的算法。

排序可以说是众多操作的基础了。而且排序的算法也很多。这儿我也就挑一些算法来展开。

通过排序算法的学习，你会发现对之前介绍的时间复杂度、空间复杂度这些概念有更多也更深刻的认识，
从今天开始，它们就不再是冷冰冰的概念了，而是你随时备在手边的武器。

首先，我们来结合排序算法来回顾一下以前的关于复杂度的学习。

*时间复杂度* 最好时间复杂度，最坏时间复杂度，平均时间复杂度。对于同样时间复杂度排序算法，如果知道
原本的数据接近有序，是不是就对选择有不同的影响了。

*空间复杂度* 关于排序，我们会使用很多原地排序算法。即是 latexmath:[$O(1)$] 的空间复杂度。

*稳定性* 在排序前相同值得元素不会在排序会被改变，这就是稳定性。

除了以上的内容，其实还有你需要关心的内容，比方说以上实现都一样，就可以考虑到单次操作的消耗了时间或者
空间了。

[bubble_sort]
=== 冒泡排序
我们首先从冒泡排序学起吧。

用文字描述一下先，冒泡排序是通过操作相邻的两个元素进行比较，然后把较大那个换到后面，依次类推，完成一次
机可以确认出最大的数，并且已经移动到最后的位置，然后再循环操作一次，就可以选出第二大...。直至完全排序
完成。

通过文字描述就可以得出，基本上需要循环操作两次，就可以粗略的得出平均时间复杂度为 latexmath:[$O(1)]
,每次操作的空间是有限的，那就肯定是 latexmath:[$O(1)$]。只是比较大的元素会被交换，意味着这肯定是
个稳定排序。

以上的仅仅是凭借着第一感觉来分析的，不过现在也够了。

[insertion_sort]
=== 插入排序

首先在需要排序的数据上，可以理解为两个区间。一边是有序的一边是需要排序的。初始状态是只有一个有序的
元素，无论大小。然后，从第二个元素提取出来开始进行比较，如果比前一个小，前面的就后移，把该位置空置留给需要的
元素，如果不比它不小，就把元素查到元素的后面，这样，有序的区间就会增加一个元素，需要排序的区间就会
少一个元素。依次类推，直至循环比较到最后一个元素，完成排序过程。

通过文字描述，我们就能猜得出来，这个空间复杂度为 latexmath:[$O(1)$], 并且它是一个稳定的排序。
然后我们来看时间复杂度，如果原本的数据就是有序的情况，那么我们只需要循环遍历比较一次依次，最好的时间
复杂度为 latexmath:[$O(n)$]，当然如果全部无序，也就是说数据是倒序的话，那每个循环子项都需要进行大量
的移动和比较，最差的时间复杂度就位 latexmath:[$O(n^2)$]。平均复杂度为 latexmath:[$O(n^2)$]。

[selection_sort]
=== 选择排序

选择排序的做法是在一个需要排序的数据中，循环操作数据长度对应的次数。第一次，用第一个元素和接下的所有
元素一一比较，比较出最小的那个，进行位置交换，把最小的那个第一个元素，第二次循环用第二个元素进行依次
循环比较，得出最小的元素，进行位置替换。依次循环到最后一个元素，完成排序操作。

通过文字描述，可以看出，这个也是个空间复杂度为 latexmath:[$O(1)$] 的原地排序算法。不过每次都需要
比较意味着不管是最好还是最坏以及平均时间复杂度都为 latexmath:[$O(n^2)$]。而且通过进行单个的元素
比较交换可以看出，这个是无法保证稳定性的。

[merge_sort]
=== 归并排序

归并排序这儿我们要学一个新的概念，分治思想。

其关键就是两步操作，第一步，一分为二的进行排序，*递归实现* 直至递归到无法无法分解为止。第二步，
归并，通过一个临时数组，来进行比较需要归并的左右两个有序数据，标记一个中点，然后比较两侧的第
一个元素，接下来就再比较两边剩下的第一个元素，直至两边数据完全排序。最后不断递归回调直至完成排序。

递归相比较冒泡排序等是略微复杂一点儿的，因为从这儿开始就打上了组合拳。

接下我们简单分析一下复杂度。从临时增加的数组可以看出，他的空间需要和需要排序是数组是一般长的，故
为 latexmath:[$O(n)$]，从排序的方式可以看出来，这十个稳定排序。时间复杂度就不好直接看出来，
那么简单的分析一下，分解过程是 latexmath:[$O(logn)$]，而归并排序的过程是 latexmath:[$O(n)$]，
这种情况下就得出为 latexmath:[$O(nlogn)$]。从分解和排序的过程来看，最好和最坏的时间复杂度都一样。
咦，一点儿都不严谨。

[quick_sort]
=== 快速排序
快速排序常被简称为快排，例如、三路快排。

快速排序和归并排序还是有很多的相似之处的，我们可以类比着来学习。那么开始吧：

快排也是采用分治和递归的方式来解题，这个也是关键的两步走。第一步，分。选择一个随机点儿进行分区，
这个点儿的左边为小于它的存在，右边为大于它的存在。第二步，*递归实现* 通过以上的划分点儿，递归
操作两边的两个分区继续进行分解排序。循环执行直至无法分解。最后完成排序。

会发现其实两种和归并相比，这个还是区别挺明显的。因为是随机的生成区分点，这就意味着最差的情况下，
时间复杂度会退化到 latexmath:[$O(n^2)$]，不过大部分情况下时间复杂度还是为
latexmath:[$O(nlogn)$]，但是优点也很明显，它可以做到原地排序，不过却做不到保持有序。

[bucket_sort]
=== 桶排序

就是利用“桶”来进行排序，其操作就是把需要排序的数据放到几个有序的桶里，每个桶单独排序。完成后再
依次取出，组成的序列就是完成排序的数据了。

听着很简单的样子，我们简单分析一下。桶的时间复杂度为 latexmath:[$O(n)$]，不过这是理想情况，
前提就是对需要排序的数据有要求，比方说，有的桶里数据多，有的桶里数据少，数据平均分布才能达到要
求。

[counting_sort]
=== 计数排序

计数排序我们可以简单的划分为三个步骤。第一步，创建一个临时的二维数组。其一维的元素就是需要排序
的数据范围值。第二步，进行计数并将对应的数据插入到临时数组对应的位置中。第三步，对把临时数组的
元素按照顺序赋值给我们需要排序的数组，完成排序。

计数排序对需要排序的数据存在一定的要求，否则需要排序的数据范围广，还存在小数、负数之类的。所以要
明白计数排序的使用场景，多用在小范围的整数排序。

[radix_sort]
=== 基数排序

基数排序，我们也分为三个步骤来做。第一步，确认需要排序的数据的位数 w，以及单个基数的比较范围 k，
注意，位数不满足的以 0 来补位。第二步，创建临时空间，空间内分为 k 个子空间，在最低位按照范围
k 的顺序插入到临时空间 。（这就和计算排序的计数过程是一样的） 第三步，依次从地位到高位重复步骤二，
直至完成排序。

计数排序，也是非比较排序，其时间复杂度可以理解为 latexmath:[$O(n)$]，但是需要注意的是，如果 k
够大，甚至说和需要排序的长度一般，那时间复杂度就是 latexmath:[$O(n^2)$]。同时这也是稳定排序，
前提是每一位的排序都是有序。

[sorting_summary]
=== 排序小结

简单小结一下，排序算法是很多算法的基础。这个是一定要熟练掌握的。比方说搜索，那是在有序的基础上来
做的，否则你肯定要一个个比较了。而且，没有最好的算法，只有更适合的算法。撇开场景谈算法无异于纸上
谈兵，所以解题的关键第一步还是对题的分析。



