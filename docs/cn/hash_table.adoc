[hash_table]
== 哈希表
哈希表我们也叫它 *散列表*，是一种将键映射到值的数据结构。

哈希表是用哈希函数来将 *键* *映射* 到小范围的存储表（数组或桶或者槽）中。嘿嘿，这么看是不是觉超
简答，没错，我也这么认为，这个时候你就要小心的。如果存储表空间不足怎么办，能不能保证不会重复映射。

接下，我们就详细的来看看你要注意的东西。

[hash_function]
=== 哈希函数

hash(key) 这就是一个哈希函数。你以为这就完了，你肯定已经明白它是用来计算键（key）的 hash 值。
不过你一定要知道的是，一个好的哈希函数需要做到什么。

- 极速计算，那必须是 latexmath:[O(1)] 级别的哈。
- 属于同一组的所有值都将映射到同一组中。即 key1 === key2 时，hash(key1) === hash(key2)。
- 需要分成不同组的值不会映射到同一组。即 key1 !== key2 时，hash(key1) !== hash(key2)。
- 尽可能的减少碰撞，
- 尽可能均匀的分配。

知道上面东西后，你就会发现，其实还是有问题存在的，散列冲突还是会存在的。常用的解决方案有两大类

[open_addressing]
==== 开放寻址法
开放寻址法的核心思想是出现冲突，我们就重新探测一块空闲位置。其具体的操作方法包括 *线性探测*、
*二次探测* 和 *双倍散列*。

*线性探测* 是在我们 *插入* 数据是发现位置已经被占用后，从当前的位置往后查找，直至找到空闲位置为止。
其实仔细想想你也会发现，随着空闲位置的变少，每次插入就可能找啊找的，多浪费时间；*查找* 更是坑爹不说，
你如果发现查找的不是你要的说明是个冲突位置，需要你挨个往后找，遇到空闲位置还找不到说明没有；
再说下 *删除* 操作，你直接删除留下的空位，可能在查找时误以为空位置就停下来，这需要你做个删除的标记，
可以让查找时继续查找。

*二次探测*

[chaining]
==== 链表法


